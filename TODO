* Consider setting concurrent_insert to 2 on MySQL to make sure we don't
have nasty locking scenarios when there are holes in the middle
of the trigrams table. See:

http://dev.mysql.com/doc/refman/5.0/en/server-system-variables.html#sysvar_concurrent_insert

Or, as an alternate way of doing defragmentation that doesn't block the server
for ages like OPTIMIZE, perhaps can just rebuild trigrams for the most-recently
inserted trigram rows until fragmentation no longer in place? In concurrent_insert
mode 1, this should cause it to reallocate those trigram rows backwards into the hole.

* Alternate strategy: stick rec_id in the index too, so that selects never
have to leave the index at all. This would also maybe allow us to switch
back to InnoDB again for greater concurrency. Benchmark, benchmark, benchmark!

* Probably should go back to using a separate trigrams table for each
searchable type. That would reduce the record size by a fair bit, and
simplify any later ideas along the lines of pre-scoped searches (i.e.
keeping school id in the trigrams table for student names).

Then again, that particular example kind of sucks, because a student's
primary school might well want to search for their name even after they're
in junior high. Possibly pre-scoped searches are not a good idea.
